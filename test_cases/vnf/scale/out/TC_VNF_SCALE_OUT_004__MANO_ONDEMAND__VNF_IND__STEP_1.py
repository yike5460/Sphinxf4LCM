import logging

from api.generic import constants
from api.generic.mano import Mano
from api.generic.traffic import Traffic
from api.generic.vim import Vim
from api.structures.objects import VnfLifecycleChangeNotification
from test_cases import TestCase
from utils.misc import generate_name

# Instantiate logger
LOG = logging.getLogger(__name__)


class TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1(TestCase):
    """
    TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1 Max vResource VNF limit reached before max NSD limit for 
    scale-out with manual scaling event generated by MANO and scaling step set to 1. The stimulus for scaling out 
    consists of value changes of one or multiple VNF related indicators on the interface produced by the VNF.

    Sequence:
    1. Ensure NFVI has vResources so that the NS can be scaled out only desired_scale_out_steps times
    2. Instantiate the NS
    3. Validate NS state is INSTANTIATED
    4. Validate VNF instantiation state is INSTANTIATED and VNF state is STARTED
    5. Start the low traffic load
    6. Validate the provided functionality and all traffic goes through
    7. Subscribe for NS Lifecycle change notifications
    8. Trigger a resize of the NS resources to the maximum by altering a VNF indicator
    9. Validate NS scale out operation was performed desired_scale_out_steps times
    10. Validate NS has resized to the max (limited by NFVI)
    11. Determine if and length of service disruption
    12. Validate traffic goes through
    """

    def setup(self):
        LOG.info('Starting setup for TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1')

        # Create objects needed by the test.
        self.mano = Mano(vendor=self.tc_input['mano_params']['type'], **self.tc_input['mano_params']['client_config'])
        self.vim = Vim(vendor=self.tc_input['vim_params']['type'], **self.tc_input['vim_params']['client_config'])
        self.traffic = Traffic(self.tc_input['traffic_params']['type'],
                               **self.tc_input['traffic_params']['client_config'])
        self.register_for_cleanup(self.traffic.destroy)

        # Initialize test case result.
        self.tc_result['overall_status'] = constants.TEST_PASSED
        self.tc_result['error_info'] = 'No errors'
        self.tc_result['events']['instantiate_ns'] = dict()
        self.tc_result['events']['scale_out_ns'] = dict()
        self.tc_result['events']['service_disruption'] = dict()

        LOG.info('Finished setup for TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1')

        return True

    def run(self):
        LOG.info('Starting TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1')

        # --------------------------------------------------------------------------------------------------------------
        # 1. Ensure NFVI has vResources so that the NS can be scaled out only desired_scale_out_steps times
        # --------------------------------------------------------------------------------------------------------------
        LOG.info('Ensuring NFVI has vResources so that the NS can be scaled out only desired_scale_out_steps times')
        # Reserving only compute resources is enough for limiting the NFVI resources
        reservation_id = self.mano.limit_compute_resources_for_ns_scaling(self.tc_input['nsd_id'],
                                                                          self.tc_input['scaling_policy_name'],
                                                                          self.tc_input['desired_scale_out_steps'],
                                                                          self.vim)
        if reservation_id is None:
            LOG.error('TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1 execution failed')
            LOG.debug('Compute resources could not be limited')
            self.tc_result['overall_status'] = constants.TEST_FAILED
            self.tc_result['error_info'] = 'Compute resources could not be limited'
            return False

        self.register_for_cleanup(self.vim.terminate_compute_resource_reservation, reservation_id)

        # --------------------------------------------------------------------------------------------------------------
        # 2. Instantiate the NS
        # --------------------------------------------------------------------------------------------------------------
        LOG.info('Instantiating the NS')
        self.time_record.START('instantiate_ns')
        self.ns_instance_id = self.mano.ns_create_and_instantiate(nsd_id=self.tc_input['nsd_id'],
                                                                  ns_name=generate_name(self.tc_input['ns']['name']),
                                                                  ns_description=None, flavour_id=None)
        if self.ns_instance_id is None:
            LOG.error('TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1 execution failed')
            LOG.debug('Unexpected NS instantiation ID')
            self.tc_result['overall_status'] = constants.TEST_FAILED
            self.tc_result['error_info'] = 'NS instantiation operation failed'
            return False

        self.time_record.END('instantiate_ns')

        self.tc_result['events']['instantiate_ns']['duration'] = self.time_record.duration('instantiate_ns')

        self.register_for_cleanup(self.mano.ns_terminate_and_delete, ns_instance_id=self.ns_instance_id)

        # --------------------------------------------------------------------------------------------------------------
        # 3. Validate NS state is INSTANTIATED
        # --------------------------------------------------------------------------------------------------------------
        LOG.info('Validating NS state is INSTANTIATED')
        ns_info = self.mano.ns_query(filter={'ns_instance_id': self.ns_instance_id})
        if ns_info.ns_state != constants.NS_INSTANTIATED:
            LOG.error('TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1 execution failed')
            LOG.debug('Unexpected NS state')
            self.tc_result['overall_status'] = constants.TEST_FAILED
            self.tc_result['error_info'] = 'NS state was not "%s" after the NS was instantiated' \
                                           % constants.NS_INSTANTIATED
            return False

        # --------------------------------------------------------------------------------------------------------------
        # 4. Validate VNF instantiation state is INSTANTIATED and VNF state is STARTED
        # --------------------------------------------------------------------------------------------------------------
        LOG.info('Validating VNF instantiation state is INSTANTIATED')

        # Get the instance ID of the VNF inside the NS
        self.vnf_instance_id = ns_info.vnf_info_id[0]

        vnf_info = self.mano.vnf_query(filter={'vnf_instance_id': self.vnf_instance_id})
        if vnf_info.instantiation_state != constants.VNF_INSTANTIATED:
            LOG.error('TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1 execution failed')
            LOG.debug('Unexpected VNF instantiation state')
            self.tc_result['overall_status'] = constants.TEST_FAILED
            self.tc_result['error_info'] = 'VNF instantiation state was not "%s" after the VNF was instantiated' \
                                           % constants.VNF_INSTANTIATED
            return False

        LOG.info('Validating VNF state is STARTED')
        if vnf_info.instantiated_vnf_info.vnf_state != constants.VNF_STARTED:
            LOG.error('TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1 execution failed')
            LOG.debug('Unexpected VNF state')
            self.tc_result['overall_status'] = constants.TEST_FAILED
            self.tc_result['error_info'] = 'VNF state was not "%s" after the VNF was instantiated' % \
                                           constants.VNF_STARTED
            return False

        self.tc_result['resources']['Initial'] = self.mano.get_allocated_vresources(self.vnf_instance_id)

        # --------------------------------------------------------------------------------------------------------------
        # 5. Start the low traffic load
        # --------------------------------------------------------------------------------------------------------------
        LOG.info('Starting the low traffic load')
        if not self.traffic.configure(traffic_load='LOW_TRAFFIC_LOAD',
                                      traffic_config=self.tc_input['traffic_params']['traffic_config']):
            LOG.error('TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1 execution failed')
            LOG.debug('Low traffic load and traffic configuration parameter could not be applied')
            self.tc_result['overall_status'] = constants.TEST_FAILED
            self.tc_result['error_info'] = 'Low traffic load and traffic configuration parameter could not be applied'
            return False

        # Configure stream destination MAC address(es)
        dest_mac_addr_list = ''
        for ext_cp_info in vnf_info.instantiated_vnf_info.ext_cp_info:
            if ext_cp_info.cpd_id == self.tc_input['traffic_params']['traffic_config']['left_cp_name']:
                dest_mac_addr_list += ext_cp_info.address[0] + ' '
        self.traffic.config_traffic_stream(dest_mac_addr_list)

        if not self.traffic.start(return_when_emission_starts=True):
            LOG.error('TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1 execution failed')
            LOG.debug('Traffic could not be started')
            self.tc_result['overall_status'] = constants.TEST_FAILED
            self.tc_result['error_info'] = 'Low traffic could not be started'
            return False

        self.register_for_cleanup(self.traffic.stop)

        # --------------------------------------------------------------------------------------------------------------
        # 6 Validate the provided functionality and all traffic goes through
        # --------------------------------------------------------------------------------------------------------------
        LOG.info('Validating the provided functionality and all traffic goes through')
        if not self.traffic.does_traffic_flow(delay_time=5):
            LOG.error('TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1 execution failed')
            LOG.debug('Traffic is not flowing')
            self.tc_result['overall_status'] = constants.TEST_FAILED
            self.tc_result['error_info'] = 'Low traffic did not flow'
            return False

        if self.traffic.any_traffic_loss():
            LOG.error('TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1 execution failed')
            LOG.debug('Traffic is flowing with packet loss')
            self.tc_result['overall_status'] = constants.TEST_FAILED
            self.tc_result['error_info'] = 'Low traffic flew with packet loss'
            return False

        self.tc_result['scaling_out']['traffic_before'] = 'LOW_TRAFFIC_LOAD'

        if not self.mano.validate_allocated_vresources(self.tc_input['vnfd_id'], self.vnf_instance_id):
            LOG.error('TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1 execution failed')
            LOG.debug('Could not validate allocated vResources')
            self.tc_result['overall_status'] = constants.TEST_FAILED
            self.tc_result['error_info'] = 'Could not validate allocated vResources'
            return False

        # --------------------------------------------------------------------------------------------------------------
        # 7. Subscribe to NS Lifecycle change notifications
        # --------------------------------------------------------------------------------------------------------------
        LOG.info('Subscribing to NS lifecycle change notifications')
        subscription_id = self.mano.ns_lifecycle_change_notification_subscribe(
                                                                         filter={'ns_instance_id': self.ns_instance_id})

        # --------------------------------------------------------------------------------------------------------------
        # 8. Trigger a resize of the NS resources to the maximum by altering a VNF indicator
        # --------------------------------------------------------------------------------------------------------------
        LOG.info('Triggering a resize of the NS resources to the maximum by altering a VNF indicator')

        # The scale out is triggered by a VNF related indicator value change.
        # The VNF exposed interface Ve-Vnfm-Vnf will enable the MANO to trigger a scale out based on VNF Indicator
        # value changes. VNF related indicators are declared in the VNFD.
        # There are 2 ways for MANO to obtain VNF Indicator information:
        # - by GetIndicatorValue operation on the Ve-Vnfm-Vnf interface
        # - by subscribing for notifications related to VNF Indicator value changes with the VNF.
        # The two operations involved are Subscribe and Notify.

        # TODO: Insert here code to:
        # 1. alter the VNF related indicators so that MANO can trigger an NS scale out
        # 2. check that MANO has subscribed to VNF
        # 3. subscribe to VNF and check the notifications
        # For now we use only traffic load to trigger the scale out (we will increase the traffic load to the maximum).
        self.traffic.config_traffic_load('MAX_TRAFFIC_LOAD')

        # --------------------------------------------------------------------------------------------------------------
        # 9. Validate NS scale out operation was performed desired_scale_out_steps times
        # --------------------------------------------------------------------------------------------------------------
        LOG.info('Validating VNF scale out operation was performed desired_scale_out_steps times')
        notification_queue = self.mano.get_notification_queue(subscription_id)

        self.time_record.START('scale_out_ns')
        # We are scaling the NS (desired_scale_out_steps + 1) times and check at the next step that the NS scaled out
        # only desired_scale_out_steps times
        for scale_out_step in range(self.tc_input['desired_scale_out_steps'] + 1):
            notification_info = self.mano.search_in_notification_queue(notification_queue=notification_queue,
                                                                       notification_type=VnfLifecycleChangeNotification,
                                                                       notification_pattern={'status': 'STARTED',
                                                                                             'operation': 'NS_SCALE.*'},
                                                                       timeout=constants.SCALE_INTERVAL)
            if notification_info is None:
                LOG.error('TC_VNFC_SCALE_OUT_004__MANO_ONDEMAND__EM_IND__STEP_1 execution failed')
                LOG.debug('Could not validate that scale out started')
                self.tc_result['overall_status'] = constants.TEST_FAILED
                self.tc_result['error_info'] = 'Could not validate that scale out started'
                return False
            notification_info = self.mano.search_in_notification_queue(notification_queue=notification_queue,
                                                                       notification_type=VnfLifecycleChangeNotification,
                                                                       notification_pattern={'status': 'SUCCESS|FAILED',
                                                                                             'operation': 'NS_SCALE.*'},
                                                                       timeout=constants.SCALE_INTERVAL)
            if notification_info is None:
                LOG.error('TC_VNFC_SCALE_OUT_004__MANO_ONDEMAND__EM_IND__STEP_1 execution failed')
                LOG.debug('Could not validate that scale out finished')
                self.tc_result['overall_status'] = constants.TEST_FAILED
                self.tc_result['error_info'] = 'Could not validate that scale out finished'
                return False
        self.time_record.END('scale_out_ns')

        self.tc_result['events']['scale_out_ns']['duration'] = self.time_record.duration('scale_out_ns')

        self.tc_result['resources']['After scale out'] = dict()
        ns_info = self.mano.ns_query(filter={'ns_instance_id': self.ns_instance_id})
        for vnf_instance_id in ns_info.vnf_info_id:
            self.tc_result['resources']['After scale out'].update(self.mano.get_allocated_vresources(vnf_instance_id))

        self.tc_result['scaling_out']['status'] = 'Success'

        # --------------------------------------------------------------------------------------------------------------
        # 10. Validate NS has resized to the max (limited by NFVI)
        # --------------------------------------------------------------------------------------------------------------
        LOG.info('Validating NS has resized to the max (limited by NFVI)')
        # The NS should have default_instances + desired_scale_out_steps * increment VNFs after scale out
        if len(ns_info.vnf_info_id) != self.tc_input['scaling']['default_instances'] + \
                                       self.tc_input['scaling']['increment'] * self.tc_input['desired_scale_out_steps']:
            LOG.error('TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1 execution failed')
            LOG.debug('NS did not scale to the max NFVI limit')
            self.tc_result['overall_status'] = constants.TEST_FAILED
            self.tc_result['error_info'] = 'NS did not scale to the max NFVI limit'
            return False
        self.tc_result['scaling_out']['level'] = self.tc_input['scaling']['default_instances'] + \
                                                 self.tc_input['scaling']['increment'] * \
                                                 self.tc_input['desired_scale_out_steps']

        # --------------------------------------------------------------------------------------------------------------
        # 11. Determine is and length of service disruption
        # --------------------------------------------------------------------------------------------------------------
        LOG.info('Determining if and length of service disruption')
        self.tc_result['events']['service_disruption']['duration'] = self.traffic.calculate_service_disruption_length()

        # --------------------------------------------------------------------------------------------------------------
        # 12. Validate traffic goes through
        # --------------------------------------------------------------------------------------------------------------
        LOG.info('Validating traffic goes through')
        # Since the NS scaled out only desired_scale_out_steps, we are not checking the traffic loss because we do not
        # expect all traffic to go through.
        # Decreasing the traffic load to normal would not be appropriate as it could trigger a scale in.
        if not self.traffic.does_traffic_flow(delay_time=5):
            LOG.error('TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1 execution failed')
            LOG.debug('Traffic is not flowing')
            self.tc_result['overall_status'] = constants.TEST_FAILED
            self.tc_result['error_info'] = 'Max traffic did not flow'
            return False

        self.tc_result['scaling_out']['traffic_after'] = 'MAX_TRAFFIC_LOAD'

        LOG.info('TC_VNF_SCALE_OUT_004__MANO_ONDEMAND__VNF_IND__STEP_1 execution completed successfully')

        return True
